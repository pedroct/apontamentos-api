name: Deploy to Production

permissions:
  contents: read
  packages: write

on:
  push:
    branches: ["main"]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  IMAGE: ghcr.io/${{ github.repository }}
  PUBLIC_HEALTH_URL: https://api-apontamentos.pedroct.com.br/healthz

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          logout: true

      - name: Build & Push image
        run: |
          docker build -t "${IMAGE}:${GITHUB_SHA}" -t "${IMAGE}:latest" .
          docker push "${IMAGE}:${GITHUB_SHA}"
          docker push "${IMAGE}:latest"

      - name: Cache server host key (port 2222)
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -p 2222 "api-apontamentos.pedroct.com.br" >> ~/.ssh/known_hosts

      - name: Check SSH connectivity (TCP 2222)
        run: |
          set -euxo pipefail
          getent ahostsv4 "api-apontamentos.pedroct.com.br" || true
          timeout 10 bash -c "exec 3<>/dev/tcp/api-apontamentos.pedroct.com.br/2222" && echo "TCP 2222 open"

      - name: SSH into server and deploy
        uses: appleboy/ssh-action@v1.2.0
        env:
          # ==== App config (defaults + secrets) ====
          APP_ENV: production
          LOG_LEVEL: ${{ secrets.LOG_LEVEL || 'INFO' }}

          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ALGORITHM: ${{ secrets.JWT_ALGORITHM || 'HS256' }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES || '60' }}

          # CORS / Hosts
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS || 'https://apontamentos.pedroct.com.br,https://api-apontamentos.pedroct.com.br' }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS || 'api-apontamentos.pedroct.com.br' }}

          # Observability
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          SENTRY_TRACES_SAMPLE_RATE: ${{ secrets.SENTRY_TRACES_SAMPLE_RATE || '0.2' }}
          SENTRY_PROFILES_SAMPLE_RATE: ${{ secrets.SENTRY_PROFILES_SAMPLE_RATE || '0.0' }}

          # GHCR login on remote host
          GHCR_USERNAME: pedroct
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          host: api-apontamentos.pedroct.com.br
          username: pedroct
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 2222
          timeout: 2m
          command_timeout: 15m
          # Make these envs available inside the remote shell:
          envs: APP_ENV,LOG_LEVEL,DATABASE_URL,JWT_SECRET,JWT_ALGORITHM,ACCESS_TOKEN_EXPIRE_MINUTES,CORS_ALLOWED_ORIGINS,ALLOWED_HOSTS,SENTRY_DSN,SENTRY_TRACES_SAMPLE_RATE,SENTRY_PROFILES_SAMPLE_RATE,GHCR_USERNAME,GHCR_TOKEN
          script: |
            set -euo pipefail

            APP_DIR="/home/pedroct/apps/apontamentos-api"
            SERVICE="api"  # nome do serviço no docker-compose.yml
            ENV_FILE="${APP_DIR}/.env"   # docker compose lê .env por padrão nesse diretório

            # 1) Atualiza/gera .env com valores REAIS (heredoc sem aspas para interpolar)
            install -d -m 0755 "$APP_DIR"
            umask 077
            tmpenv="$(mktemp)"
            cat > "$tmpenv" <<EOF
            # ==== app required settings ====
            APP_ENV=${APP_ENV}
            LOG_LEVEL=${LOG_LEVEL}

            DATABASE_URL=${DATABASE_URL}
            JWT_SECRET=${JWT_SECRET}
            JWT_ALGORITHM=${JWT_ALGORITHM}
            ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}

            # CORS / Hosts
            CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS}
            ALLOWED_HOSTS=${ALLOWED_HOSTS}

            # Observability
            SENTRY_DSN=${SENTRY_DSN}
            SENTRY_TRACES_SAMPLE_RATE=${SENTRY_TRACES_SAMPLE_RATE}
            SENTRY_PROFILES_SAMPLE_RATE=${SENTRY_PROFILES_SAMPLE_RATE}
            # ==== end ====
            EOF
            mv "$tmpenv" "$ENV_FILE"

            # 2) (Opcional) Mostra apenas as CHAVES presentes (sem vazar valores)
            echo "Env keys presentes no ${ENV_FILE}:"
            sed -E 's/^(.*)=.*$/\1=****/' "$ENV_FILE" | grep -v '^\s*$' || true

            # 3) Login no GHCR e rollout
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

            cd "$APP_DIR"
            docker compose pull
            docker compose up -d --remove-orphans
            docker image prune -f

            # 4) Aguarda container ficar running
            for i in {1..30}; do
              if docker compose ps --status=running | grep -q "$SERVICE"; then
                echo "Serviço $SERVICE está em execução."
                break
              fi
              sleep 2
              if [ "$i" -eq 30 ]; then
                echo "Serviço $SERVICE não ficou running a tempo."
                docker compose ps || true
                exit 1
              fi
            done

            # 5) Healthcheck do Docker (ou fallback interno)
            CID=$(docker compose ps -q "$SERVICE" || true)
            if [ -n "$CID" ] && docker inspect "$CID" | grep -q '"Health"'; then
              echo "Aguardando HEALTHCHECK do Docker ficar healthy..."
              for i in {1..60}; do
                status=$(docker inspect -f '{{.State.Health.Status}}' "$CID" || echo "unknown")
                echo "Health status: $status"
                [ "$status" = "healthy" ] && { echo "Health OK (Docker HEALTHCHECK)."; break; }
                sleep 2
                if [ "$i" -eq 60 ]; then
                  echo "Health do Docker não ficou healthy em tempo hábil."
                  docker logs --tail=200 "$CID" || true
                  echo "Variáveis de ambiente no container:"
                  docker exec "$CID" /bin/sh -lc 'env | sed -E "s/^(.*)=.*$/\1=****/" | sort' || true
                  exit 1
                fi
              done
            else
              echo "Sem HEALTHCHECK no Docker; testando endpoint /healthz de dentro do container…"
              for i in {1..60}; do
                if docker compose exec -T "$SERVICE" sh -lc 'curl -fsS http://127.0.0.1:8000/healthz >/dev/null'; then
                  echo "Local health OK (in-container)."
                  break
                fi
                sleep 2
                if [ "$i" -eq 60 ]; then
                  echo "Health interno falhou."
                  [ -n "$CID" ] && docker logs --tail=200 "$CID" || true
                  docker compose ps || true
                  exit 1
                fi
              done
            fi

      - name: Public smoke test (HTTPS)
        run: |
          for i in {1..60}; do
            code=$(curl -sk -o /dev/null -w "%{http_code}" "${PUBLIC_HEALTH_URL}")
            if [ "$code" = "200" ]; then
              echo "OK ${PUBLIC_HEALTH_URL}"
              curl -fsS "${PUBLIC_HEALTH_URL}"
              exit 0
            fi
            sleep 2
          done
          echo "Falha no smoke test público em ${PUBLIC_HEALTH_URL}"
          exit 1
